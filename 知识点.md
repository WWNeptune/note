cin>>等价于cin.operator>>()；

如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。如果后续接getline()要记得处理换行符！

不想略过空白字符，那就使用 noskipws 流控制。比如
cin>>noskipws>>input

cin.get()只能读取其中一个字符，可以传入数组及读取长度	cin.get(a,n);  a为数组

getline(缓存对象，长度，截断字符)接受一个字符串，第三个参数默认\0，可以接收空格并输出,吃掉末尾的换行符

对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一
个数组，delete删除一个指针。

通过基类类型的指针访问派生类自己的虚函数将发生错误

 虚函数表属于类，类的所有对象共享这个类的虚函数表，虚函数指针属于实例。子类继承父类虚函数表中的虚函数地址数据，不是同一张表

泛型编程即以一种独立于任何特定类型的方式编写代码。

1：可用来创建动态增加或减少的数据结构
2：它与某种特定类型无关，因此代码可重复使用
3：它在编译时检查数据类型而不是运行时检查数据类型，保证了类型的安
全
4：它是平台无关的，具有很好的移植性
5：可用于基本数据类型

多态：是对于不同对象接收相同消息时产生不同的动作

函数重载：允许有不同参数的函数有相同的名字。
虚函数：子类重新定义父类的虚函数
模板函数：某函数进行的操作一样，只是操作的数据类型不同，可以用模板

引用就是某个目标变量的“别名”(alias)引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用

重载（overload）是指函数名相同，参数列表不同

重写（overwrite）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写

重载和多态无关  重写和多态真正相关

C++两个不同类型的指针之间可以强制转换

对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。

**main函数执行之前，主要就是初始化系统相关资源：**
设置栈指针
初始化静态static 变量和global 全局变量，即.data 段的内容

将未初始化部分的全局变量赋初值即.bss 段的内容
全局对象初始化，在main 之前调用构造函数，这是可能会执行前的一些代码
将main函数的参数argc ， argv 等传递给main 函数，然后才真正运行main 函数
__attribute__((constructor))

**main函数执行之后：**
全局对象的析构函数会在main函数之后执行；
可以用 atexit 注册一个函数，它会在main 之后执行;
__attribute__((destructor))

sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数	sizeof是编译时运算符，编译时就确定了

C++求数组元素个数:int l = sizeof(a)/sizeof(a[0]);

int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

引用与指针不同点：指针是一个新的变量（实体），指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作	引用是类型安全的

需要返回函数内局部变量的内存的时候用指针,类对象作为参数传递的时候使用引用

拷贝构造函数:类的一个对象去初始化另一个对象		函数的参数是类的对象	函数的返回值是类的对象或者引用

const作用：定义常量、修饰函数参数、修饰函数返回值

typedef 仅限于为类型定义符号名称			#define 不仅可以为类型定义别名，也能为数值定义别名

sizeof 不计算 static 变量占得内存

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

类型转换： static_cast	const_cast	dynamic_cast	reinterpret_cast:重新解释

不能声明为inline：包含了递归、循环等结构的函数		虚拟函数		通过函数指针调用内联函数		构造和析构函数	内联函数调用了其他函数

**类体**定义的成员函数为inline函数，在类外定义的不是。			static修饰的inline函数

使用智能指针：

1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据。

野指针：1.指针定义时未被初始化		2.指针被释放时没有置空		3.指针操作超越变量作用域

当源和目标重叠，memcpy不能确保重叠区域的原始源字节在被覆盖之前被复制。

解决方法：从源末端复制

string转char*	const char* p = str.data();	const char *p = str.c_str();		str.copy(p, 5, 0);

char*/char[]转string	直接赋值

数字转字符串	s += std:: to_string(3.141592653589);

字符串转数字	stoi(int),stol(long), stof(float), stod(double)		int n = stoi(str);

Volatile 关键字表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问

为什么静态成员函数可以访问私有成员变量？（访问控制是针对类而不是针对对象）

静态成员函数要访问非静态成员时，要用过对象来引用

类的隐式类型转换：1.单参数的构造函数会造成隐形类型的转换	2.自定义的operator type()操作符

任何只接受一个参数的构造函数，都隐式地定义了由该参数向该类型的隐式类型转换，如A(int i)定义了一个由int向A的隐式类型转换

explicit阻止类隐式转换的发生

正常情况下，是可以使用metset初始化类对象的，但是如果该类含有虚函数，那么这个对象本身指向虚函数表的指针也会被初始化为null，从而找不到该类的虚函数表，当我们想要利用该类发生多态时，程序崩溃

extern "C" { }为了能够正确实现 C++代码调用其他 C 语言代码，实现 C++与 C 及其它语言的混合编

malloc分配内存：一种是采用推进 brk 指针来增加堆的有效区域来申请内存空间，还有一种是采用 mmap 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存

auto：auto不能作为函数参数		非静态auto类型不能成员变量	auto不能作为模板实例化类型

当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；		auto 定义的变量必须有初始值

decltype对顶层const和引用的处理方式与auto不同，decltype附带原本的const与引用属性

段错误就是指访问的内存超出了系统所给这个程序的内存空间。

只有当物件是使用 new创建的（不是通过 new[ ]，不是 placement new，不是栈上的局部对象，不是全局对象，不是另一个对象的数据成员），才能使用delete this 来销毁。

内存泄漏：

1. 在类的构造函数和析构函数中没有匹配的调用 new 和 delete 函数
2. 没有正确地清除嵌套的对象指针
3. 在释放对象数组时在 delete 中没有使用方括号
4. 指向对象的指针数组不等同于对象数组       delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了

5. 缺少拷贝构造函数/重载赋值运算符
6. 两次释放相同的内存

7.没有将基类的析构函数定义为虚函数

避免方法：malloc/free要配套	使用智能指针；	将基类的析构函数设为虚函数
全局（静态）存储区：分为DATA段和BSS段。

构造函数不能写为虚函数（运行时确定类型），析构可以，但必须提供纯虚析构函数的定义

为什么用成员初始化列表会快一些：直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程

必须使用成员初始化列表进行初始化：常量成员		引用类型		没有默认构造函数的对象		派生类必须在其初始化列表中调用基类的构造函数

类所占内存的大小是由成员变量（静态变量除外）决定的，虚函数指针和虚基类指针也属于数据部分，成员函数是不计算在内的

新建一个空类,里面有什么函数：6 个：默认构造函数、拷贝构造、赋值运算符、析构函数、取址运算符、const 取址运算符

友元函数：定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明

友元关系不能被继承		友元关系是单向的		友元关系不具有传递性

malloc是通过两个系统调用来实现的： brk和mmap

单一职责原则SRP:是指一个类的功能要单一，不能包罗万象

开放封闭原则OCP:一个模块在**扩展性**方面应该是开放的而在**更改性**方面应该是封闭的。

里式替换原则LSP:子类应当可以**替换父类**并出现在父类能够出现的任何地方

依赖倒置原则DIP：具体依赖抽象，上层依赖下层

接口分离原则ISP:模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

编译器会对函数模板进行两次编译，在声明处对模板代码本身进行编译（检查语法），在调用处对参数替换后的代码进行编译。

函数模板允许隐式调用和显式调用而类模板只能显示调用。

```c++
template<typename T>/*类模板继承*/
class B:public A<typename T>{};
```

使用了裸指针来构造**shared_ptr**智能指针时，那么在后续的代码中。就不要再使用该裸指针

一个裸指针**只能绑定到**一个shared_ptr中

不要把类对象指针(this指针)作为shared_ptr返回，改用enable_shared_from_this

```c++
class CT:public enable_shared_from_this<CT> {
public:
shared_ptr<CT>getself() {
	return shared_from_this();
}
```

shared_ptr和weak_ptr的尺寸是裸指针的2倍

shared_ptr内部的引用计数是原子的操作，所以是线程安全的；同一个shared_ptr被多线程写，不是线程安全，共享引用计数的安全

vector的emplace_back()在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造

STL的sort算法，数据量较大的时候，采用快速排序，**分段递归**。一旦分段后数据量小于某个阀值（16），改用插入排序。递归到达一定层次采用堆排序

STL容器不是线程安全的

stack 和 queue 底层一般用 list 或 deque 实现，封闭头部即可

map 的内部实现是二叉平衡树(红黑树），有序	unordered_map 的实现是哈希表；无序

set所有的元素都会被自动排序，只含有 Key
map所有元素是通过键进行自动排序的，适合存储一个数据字典

set 不能直接改变元素值，map的key是不能修改的，但可以通过 key改变 value 的值

不允许有遍历：queue，stack，heap

关联容器，删除当前的 iterator，仅仅会使当前的 iterator 失效；序列式容器都失效

共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源

CPU 密集型任务配置尽可能少的线程数		IO密集型任务中使用多线程可以大大的加速

父子进程不共享数据段和堆栈空间。

半开连接：：TCP连接的一端异常崩溃，或者在未通知对端的情况下关闭连接

半关连接是指：TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据

进程5种状态：新建 就绪 运行 阻塞 终止

为什么不可以三次挥手：

因为释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为**还有必要的数据需要处理**，所以服务器先返回 ACK 确认收到报文，经过CLOSE-WAIT 阶段准备好释放连接之后，才能返回 FIN 释放连接报文

TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。流量控制就是动态调节窗口大小发送数据包。

拥塞控制方法：慢启动		拥塞避免		快重传		快速恢复

拥塞控制是防止网络发生拥塞；而流量控制是防止接收方缓存放不下。都是对发送方的行为进行控制的。