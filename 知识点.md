cin>>等价于cin.operator>>()；

如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。如果后续接getline()要记得处理换行符！

不想略过空白字符，那就使用 noskipws 流控制。比如
cin>>noskipws>>input

cin.get()只能读取其中一个字符，可以传入数组及读取长度	cin.get(a,n);  a为数组

getline(缓存对象，长度，截断字符)接受一个字符串，第三个参数默认\0，可以接收空格并输出,吃掉末尾的换行符

对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一
个数组，delete删除一个指针。

通过基类类型的指针访问派生类自己的虚函数将发生错误

 虚函数表属于类，类的所有对象共享这个类的虚函数表，虚函数指针属于实例。子类继承父类虚函数表中的虚函数地址数据，不是同一张表

泛型编程即以一种独立于任何特定类型的方式编写代码。

1：可用来创建动态增加或减少的数据结构
2：它与某种特定类型无关，因此代码可重复使用
3：它在编译时检查数据类型而不是运行时检查数据类型，保证了类型的安
全
4：它是平台无关的，具有很好的移植性
5：可用于基本数据类型

多态：是对于不同对象接收相同消息时产生不同的动作

函数重载：允许有不同参数的函数有相同的名字。
虚函数：子类重新定义父类的虚函数
模板函数：某函数进行的操作一样，只是操作的数据类型不同，可以用模板

引用就是某个目标变量的“别名”(alias)引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用

重载（overload）是指函数名相同，参数列表不同

重写（overwrite）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写

重载和多态无关  重写和多态真正相关

C++两个不同类型的指针之间可以强制转换

对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。

**main函数执行之前，主要就是初始化系统相关资源：**
设置栈指针
初始化静态static 变量和global 全局变量，即.data 段的内容

将未初始化部分的全局变量赋初值即.bss 段的内容
全局对象初始化，在main 之前调用构造函数，这是可能会执行前的一些代码
将main函数的参数argc ， argv 等传递给main 函数，然后才真正运行main 函数
__attribute__((constructor))

**main函数执行之后：**
全局对象的析构函数会在main函数之后执行；
可以用 atexit 注册一个函数，它会在main 之后执行;
__attribute__((destructor))

sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数	sizeof是编译时运算符，编译时就确定了

C++求数组元素个数:int l = sizeof(a)/sizeof(a[0]);

int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

引用与指针不同点：指针是一个新的变量（实体），指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作	引用是类型安全的

需要返回函数内局部变量的内存的时候用指针,类对象作为参数传递的时候使用引用

拷贝构造函数:类的一个对象去初始化另一个对象		函数的参数是类的对象	函数的返回值是类的对象或者引用

const作用：定义常量、修饰函数参数、修饰函数返回值

typedef 仅限于为类型定义符号名称			#define 不仅可以为类型定义别名，也能为数值定义别名

sizeof 不计算 static 变量占得内存

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

类型转换： static_cast	const_cast	dynamic_cast	reinterpret_cast:重新解释

不能声明为inline：包含了递归、循环等结构的函数		虚拟函数		通过函数指针调用内联函数		构造和析构函数	内联函数调用了其他函数

**类体**定义的成员函数为inline函数，在类外定义的不是。			static修饰的inline函数

使用智能指针：

1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据。

野指针：1.指针定义时未被初始化		2.指针被释放时没有置空		3.指针操作超越变量作用域

当源和目标重叠，memcpy不能确保重叠区域的原始源字节在被覆盖之前被复制。

解决方法：从源末端复制

string转char*	const char* p = str.data();	const char *p = str.c_str();		str.copy(p, 5, 0);

char*/char[]转string	直接赋值

数字转字符串	s += std:: to_string(3.141592653589);

字符串转数字	stoi(int),stol(long), stof(float), stod(double)		int n = stoi(str);

Volatile 关键字表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问

为什么静态成员函数可以访问私有成员变量？（访问控制是针对类而不是针对对象）

静态成员函数要访问非静态成员时，要用过对象来引用

类的隐式类型转换：1.单参数的构造函数会造成隐形类型的转换	2.自定义的operator type()操作符

任何只接受一个参数的构造函数，都隐式地定义了由该参数向该类型的隐式类型转换，如A(int i)定义了一个由int向A的隐式类型转换

explicit阻止类隐式转换的发生

正常情况下，是可以使用metset初始化类对象的，但是如果该类含有虚函数，那么这个对象本身指向虚函数表的指针也会被初始化为null，从而找不到该类的虚函数表，当我们想要利用该类发生多态时，程序崩溃

extern "C" { }为了能够正确实现 C++代码调用其他 C 语言代码，实现 C++与 C 及其它语言的混合编

malloc分配内存：一种是采用推进 brk 指针来增加堆的有效区域来申请内存空间，还有一种是采用 mmap 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存