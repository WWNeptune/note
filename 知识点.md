cin>>等价于cin.operator>>()；

如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。如果后续接getline()要记得处理换行符！

不想略过空白字符，那就使用 noskipws 流控制。比如cin>>noskipws>>input

cin.ignore(a, ch)有两个参数，如果计数值达到 a 或者被抛弃的字符是 ch ，则cin.ignore() 函数执行终止。一个常用功能就是用来清除以回车结束的输入缓冲区的内容

istringstream calibStream(calibData)，把calibData转为流形式的calibStream，可再用于getline

cin.get()只能读取其中一个字符，可以传入数组及读取长度	cin.get(a,n);  a为数组

getline(缓存对象，长度，截断字符)接受一个字符串，第三个参数默认\0，可以接收空格并输出,吃掉末尾的换行符

对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。

通过基类类型的指针访问派生类自己的虚函数将发生错误

 虚函数表属于类，类的所有对象共享这个类的虚函数表，虚函数指针属于实例。子类继承父类虚函数表中的虚函数地址数据，不是同一张表

泛型编程即以一种独立于任何特定类型的方式编写代码。

1：可用来创建动态增加或减少的数据结构
2：它与某种特定类型无关，因此代码可重复使用
3：它在编译时检查数据类型而不是运行时检查数据类型，保证了类型的安全
4：它是平台无关的，具有很好的移植性
5：可用于基本数据类型

多态：是对于不同对象接收相同消息时产生不同的动作

函数重载：允许有不同参数的函数有相同的名字。
虚函数：子类重新定义父类的虚函数
模板函数：某函数进行的操作一样，只是操作的数据类型不同，可以用模板

引用就是某个目标变量的“别名”(alias)引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用

重载（overload）是指函数名相同，参数列表不同

重写（overwrite）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写

重载和多态无关  重写和多态真正相关

C++两个不同类型的指针之间可以强制转换

对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。

**main函数执行之前，主要就是初始化系统相关资源：**
设置栈指针
初始化静态static 变量和global 全局变量，即.data 段的内容

将未初始化部分的全局变量赋初值即.bss 段的内容
全局对象初始化，在main 之前调用构造函数，这是可能会执行前的一些代码
将main函数的参数argc ， argv 等传递给main 函数，然后才真正运行main 函数
__attribute__((constructor))

**main函数执行之后：**
全局对象的析构函数会在main函数之后执行；
可以用 atexit 注册一个函数，它会在main 之后执行;
__attribute__((destructor))

sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数	sizeof是编译时运算符，编译时就确定了

C++求数组元素个数:int l = sizeof(a)/sizeof(a[0]);

int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

引用与指针不同点：指针是一个新的变量（实体），指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作	引用是类型安全的

需要返回函数内局部变量的内存的时候用指针,类对象作为参数传递的时候使用引用

拷贝构造函数:类的一个对象去初始化另一个对象		函数的参数是类的对象	函数的返回值是类的对象或者引用

const作用：定义常量、修饰函数参数、修饰函数返回值

typedef 仅限于为类型定义符号名称			#define 不仅可以为类型定义别名，也能为数值定义别名

sizeof 不计算 static 变量占得内存

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

类型转换： static_cast	const_cast	dynamic_cast	reinterpret_cast:重新解释

不能声明为inline：包含了递归、循环等结构的函数		虚拟函数		通过函数指针调用内联函数		构造和析构函数	内联函数调用了其他函数

**类体**定义的成员函数为inline函数，在类外定义的不是。			static修饰的inline函数

使用智能指针：

1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据。

野指针：1.指针定义时未被初始化		2.指针被释放时没有置空		3.指针操作超越变量作用域

当源和目标重叠，memcpy不能确保重叠区域的原始源字节在被覆盖之前被复制。

解决方法：从源末端复制

string转char*	const char* p = str.data();	const char *p = str.c_str();		str.copy(p, 5, 0);

char*/char[]转string	直接赋值

数字转字符串	s += std:: to_string(3.141592653589);

字符串转数字	stoi(int),stol(long), stof(float), stod(double)		int n = stoi(str);

Volatile 关键字表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问

为什么静态成员函数可以访问私有成员变量？（访问控制是针对类而不是针对对象）

静态成员函数要访问非静态成员时，要用过对象来引用

类的隐式类型转换：1.单参数的构造函数会造成隐形类型的转换	2.自定义的operator type()操作符

任何只接受一个参数的构造函数，都隐式地定义了由该参数向该类型的隐式类型转换，如A(int i)定义了一个由int向A的隐式类型转换

explicit阻止类隐式转换的发生

正常情况下，是可以使用metset初始化类对象的，但是如果该类含有虚函数，那么这个对象本身指向虚函数表的指针也会被初始化为null，从而找不到该类的虚函数表，当我们想要利用该类发生多态时，程序崩溃

extern "C" { }为了能够正确实现 C++代码调用其他 C 语言代码，实现 C++与 C 及其它语言的混合编

malloc分配内存：一种是采用推进 brk 指针来增加堆的有效区域来申请内存空间，还有一种是采用 mmap 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存

auto：auto不能作为函数参数		非静态auto类型不能成员变量	auto不能作为模板实例化类型

当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；		auto 定义的变量必须有初始值

decltype对顶层const和引用的处理方式与auto不同，decltype附带原本的const与引用属性

段错误就是指访问的内存超出了系统所给这个程序的内存空间。

只有当物件是使用 new创建的（不是通过 new[ ]，不是 placement new，不是栈上的局部对象，不是全局对象，不是另一个对象的数据成员），才能使用delete this 来销毁。

内存泄漏：

1. 在类的构造函数和析构函数中没有匹配的调用 new 和 delete 函数
2. 没有正确地清除嵌套的对象指针
3. 在释放对象数组时在 delete 中没有使用方括号
4. 指向对象的指针数组不等同于对象数组       delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了

5. 缺少拷贝构造函数/重载赋值运算符
6. 两次释放相同的内存

7.没有将基类的析构函数定义为虚函数

避免方法：malloc/free要配套	使用智能指针；	将基类的析构函数设为虚函数
全局（静态）存储区：分为DATA段和BSS段。

构造函数不能写为虚函数（运行时确定类型），析构可以，但必须提供纯虚析构函数的定义

为什么用成员初始化列表会快一些：直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程

必须使用成员初始化列表进行初始化：常量成员		引用类型		没有默认构造函数的对象		派生类必须在其初始化列表中调用基类的构造函数

类所占内存的大小是由成员变量（静态变量除外）决定的，虚函数指针和虚基类指针也属于数据部分，成员函数是不计算在内的

新建一个空类,里面有什么函数：6 个：默认构造函数、拷贝构造、赋值运算符、析构函数、取址运算符、const 取址运算符

友元函数：定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明

友元关系不能被继承		友元关系是单向的		友元关系不具有传递性

malloc是通过两个系统调用来实现的： brk和mmap

单一职责原则SRP:是指一个类的功能要单一，不能包罗万象

开放封闭原则OCP:一个模块在**扩展性**方面应该是开放的而在**更改性**方面应该是封闭的。

里式替换原则LSP:子类应当可以**替换父类**并出现在父类能够出现的任何地方

依赖倒置原则DIP：具体依赖抽象，上层依赖下层

接口分离原则ISP:模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

编译器会对函数模板进行两次编译，在声明处对模板代码本身进行编译（检查语法），在调用处对参数替换后的代码进行编译。

函数模板允许隐式调用和显式调用而类模板只能显示调用。

```c++
template<typename T>/*类模板继承*/
class B:public A<typename T>{};
```

使用了裸指针来构造**shared_ptr**智能指针时，那么在后续的代码中。就不要再使用该裸指针

一个裸指针**只能绑定到**一个shared_ptr中

不要把类对象指针(this指针)作为shared_ptr返回，改用enable_shared_from_this

```c++
class CT:public enable_shared_from_this<CT> {
public:
shared_ptr<CT>getself() {
	return shared_from_this();
}
```

shared_ptr和weak_ptr的尺寸是裸指针的2倍

shared_ptr内部的引用计数是原子的操作，所以是线程安全的；同一个shared_ptr被多线程写，不是线程安全，共享引用计数的安全

vector的emplace_back()在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造

STL的sort算法，数据量较大的时候，采用快速排序，**分段递归**。一旦分段后数据量小于某个阀值（16），改用插入排序。递归到达一定层次采用堆排序

STL容器不是线程安全的

stack 和 queue 底层一般用 list 或 deque 实现，封闭头部即可

map 的内部实现是二叉平衡树(红黑树），有序	unordered_map 的实现是哈希表；无序

set所有的元素都会被自动排序，只含有 Key
map所有元素是通过键进行自动排序的，适合存储一个数据字典

set 不能直接改变元素值，map的key是不能修改的，但可以通过 key改变 value 的值

不允许有遍历：queue，stack，heap

关联容器，删除当前的 iterator，仅仅会使当前的 iterator 失效；序列式容器都失效

共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源

CPU 密集型任务配置尽可能少的线程数		IO密集型任务中使用多线程可以大大的加速

父子进程不共享数据段和堆栈空间。

半开连接：：TCP连接的一端异常崩溃，或者在未通知对端的情况下关闭连接

半关连接是指：TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据

进程5种状态：新建 就绪 运行 阻塞 终止

为什么不可以三次挥手：

因为释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为**还有必要的数据需要处理**，所以服务器先返回 ACK 确认收到报文，经过CLOSE-WAIT 阶段准备好释放连接之后，才能返回 FIN 释放连接报文

TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。流量控制就是动态调节窗口大小发送数据包。

拥塞控制方法：慢启动		拥塞避免		快重传		快速恢复

拥塞控制是防止网络发生拥塞；而流量控制是防止接收方缓存放不下。都是对发送方的行为进行控制的。

TCP保证可靠：校验和		确认应答+序列号		超时重传		流量控制/拥塞控制

SYN攻击：半连接阻塞，是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，

GET：从指定的资源请求数据			POST：向指定的资源提交要被处理的数据

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据

io多路复用指的是同一个进（线）程可以处理多个IO数据流

协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。

只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成

协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里

预编译：文本操作		编译：生成相应的汇编代码文件		汇编：汇编到机器码	链接：将有关的目标文件彼此相连接

并发：交替做	并行：同时做

零拷贝技术可以在某种程度上减少甚至完全避免不必要 CPU 数据拷贝操作。可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率。

异常是由CPU产生的，而中断是由硬件设备产生的

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放**当前访问的若干页表项**，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

会话（Session）是一个或多个进程组的集合。进程组（process group）也是一组进程的集合

磁盘调度：1.先来先服务	2.最短寻道时间优先，容易出现饥饿现象	3.电梯扫描算法 总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为**抖动**，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数

对每一个进程，虚拟内存管理器都会将其一定量的内存页驻留在物理内存中。并跟踪其执行的性能指标，动态调整这个数量

UTF-8：可变长编码

计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码

处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作

**总线锁**就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁

当多个线程访问一个对象时，不需要考虑不能同时写入或者读写不能并行的问题，也不需要做额外的同步操作，那么就说这个对象是**线程安全**的。

进程调度：非抢占：先来先服务  短作业优先  高响应比优先  抢占：最短剩余时间

长作业：CPU繁忙	短作业：IO繁忙

僵尸进程虽然不占有任何内存空间，但其进程号就会一直被占用

不稳定排序：希尔，选择，堆排序，快排



MySQL使用B+树：双链表范围查询，树更低磁盘IO更少	B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树只能中序遍历所有节点

关系型数据库是一个结构化的数据库，创建在关系模型（二维表格模型）基础上，一般面向于记录。

非关系型数据库基于键值对

事务ACID：原子性	一致性	隔离性	持久性

事务处理只支持InnoDB和BDB，靠**日志恢复**和**并发控制**实现的

Innodb不支持全文索引，而MyISAM支持全文索引

Innodb为什么要用自增id作为主键：为了维持树的有序性，减少页分裂

哪些列不适合建索引：
很少查询的列
更新很频繁的列
数据值的取值比较少的列（比如性别）

Mysql的优化：

高频访问：分表分库	增加缓存	增加数据库的索引

并发优化：主从读写分离	负载均衡集群

脏读：读取了实际未提交的数据	幻读：在同一个事务中，**同一个**查询多次返回的结果不一致	不可重复读：在同一个事务范围内，对于同一份数据，**两个**相同的查询读取到的结果不一致

悲观锁是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写

乐观锁只有到数据提交的时候才验证数据是否存在冲突

MySQL的内部构造

**服务层**包括连接器、查询缓存、分析器、优化器、执行器		**存储引擎层**负责数据的存储和提取

MySQL索引数据结构：哈希，BTree

Redis五种数据结构：简单动态字符串，链表，字典（哈希表），跳跃表，压缩列表

网络数据包到来：

1. ⽹卡将数据帧 DMA 到内存的 RingBuffer 中，然后向 CPU 发起硬中断通知
2. CPU 响应硬中断请求，调⽤⽹卡启动时注册的硬中断处理函数
3. 硬中断处理函数⼏乎没⼲啥，就发起了软中断请求
4. 内核线程 ksoftirqd 线程发现有软中断请求到来，先关闭硬中断
5. ksoftirqd 线程开始调⽤驱动的 poll 函数收包
6. poll 函数将收到的包送到协议栈注册的 ip_rcv 函数中
7. ip_rcv 函数再将包送到 tcp_rcv_v4/udp_rcv 函数

DPDK：让用户进程能绕开内核协议栈，自己直接从网卡接收数据



epoll_create 实现：在⽤户进程调⽤ epoll_create 时，内核会创建⼀个 struct eventpoll 的内核对象。并同样把它关联到当前进程的已打开⽂件列表中。

wq： 等待队列链表		rbr： ⼀棵红⿊树		rdllist： 就绪的描述符的链表

epoll_ctl 添加 socket：

1.分配⼀个红⿊树节点对象 epitem，设置 指向eventpool和socket。
2.添加等待事件到 socket 的等待队列中，ep_poll_callback 设置为数据就绪时候的回调函数。
3.将 epitem 插⼊到 epoll 对象的红⿊树⾥。

epoll_wait 做的事情不复杂，当它被调⽤时它观察 eventpoll->rdllist 链表⾥有没有数据即可。有数据就返回，没有数据就创建⼀个等待队列项，将其添加到 eventpoll 的等待队列上，然后把⾃⼰阻塞掉就完事

阻塞：进程因为等待某个事件而主动让出CPU挂起的操作

epoll高性能最根本的原因是极大程度地减少了无用的进程上下文切换

在内核的硬、软中断上下文中，包从网卡接收过来进行处理，然后放到socket的接收队列。再找到socket关联的epitem,并把它添加到epoll对象的就绪链表中。

epoll 本身是阻塞的，但一般会把 socket 设置成非阻塞

当 socket 上数据就绪时候，内核将以 sock_def_readable 这个函数为入口，找到 epoll_ctl 添加 socket 时在其上设置的回调函数 ep_poll_callback。

在 ep_poll_callback 根据等待任务队列项上的额外的 base 指针可以找到 epitem， 进而也可以找到 eventpoll对象。

第一件事就是**把自己的 epitem 添加到 epoll 的就绪队列中**。

接着它又会查看 eventpoll 对象上的等待队列里是否有等待项（epoll_wait 执行的时候会设置）。如果没执行软中断的事情就做完了。如果有等待项，那就查找到等待项里设置的回调函数。

FCFS：先来先服务	SHF：短作业优先	HRRF：高响应比优先	